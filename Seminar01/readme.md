# Допълнение към курса по УП. Изброен тип. Запознаване със структури.

## Резюме
1. Кратък преговор на указатели, референции и работа с памет.
2. Запознаване с функции от по - висок ред.
3. Запознаване с понятието за структура.
   Създаване и работа със структура.
   Подаване на структура във функция.
   Масиви от структури.
4. Изброен тип.

## Кратък преговор на указатели, референции и работа с памет.

### Указатели и референции

Всяка променлива има стойност и адрес.

* Указателя е променлива, която съдържа адреса на друга променлива.

* Като всяка променлива указателя има стойност (адрес) и свой собствен адрес. 
* Указателите могат да променят адреса, към който сочат. 
* Могат и да четат или променят информацията, записана в този адрес. 
* Указателя може да сочи към валидна променлива или nullptr (нулевия указател).

```cpp
int main()
{
    // a is variable having a value 10
    // and a memory address 0x1a911ff9ac (as example)
    int a = 10;

    // &a is used to get a's address.
    // T* is pointer-to-T

    // b is a variable having a value 0x1a911ff9ac
    // and address 0xafcd1ffa80 (as example)
    int* b = &a;

    // We can use b to read a's value:
    std::cout << a << " " << *b << std::endl; // 10 10

    // We can use b to change a's value
    *b = 11;
    std::cout << a << std::endl; // 11 

    b = nullptr;
    std::cout << *b << std::endl; // This is bad - error occurs (segmentation fault).
}
```

* За референциите можем да си мислим като за псевдоними към други променливи.
* Всяка промяна, която направим по референция към променливата, се отразява на самата променлива.
* Референцията никога не може да е неинициализирана или нулева.
* Референцията не може да променя променливата, която реферира.

```cpp
int main()
{
    int a = 10;
    int& b = a;

    b = 11;

    std::cout << a << " " << b;
    // 11 11
}
```

### Памет
Паметта, която можем да използваме в C++ има 4 основни типа:

**Глобална (Статична)**: в тази памет се записват статичните/глобалните променливи.

* **Стекова (stack)**: 
    * Съдържа "локалните" променливи, т.е. онези, които са дефинирани в телата на функции и са същевременно нестатични.
    * Заделя се в момента на дефиниция на променливите и се освобождава в момента на изход от scope-a, в която е дефинирана;
    * Последно заделената памет се освобождава първа (First in Last out);
    * Количеството заделена памет е определена по време на компилация;
    * Ние нямаме контрол над управлението над паметта

* **Динамична (heap)**: 
    * "свободната" част от паметта, която се използва (динамично) в хода на програмата.
    * Заделя се и се освобождава по всяко време на изпълнение на програмата;
    * Областта за динамична памет е набор от свободни блокове памет;
    * Програмата може да заяви блок с произволна големина;
    * Имаме контрол над управлението на паметта;

* **Program Code**: 
    * Памет, в която се пази нашият компилиран код
    * Може да се достъпва с function pointer-и

Динамичната памет се заделя по време на изпълнение на програмата. След като бъде заделена получаваме указател към паметта.


```cpp
int main()
{
    int a = 10;           // Stored on the stack
    int* b = new int(20); // Stored on th heap
    int* c = new int[10]; // 10 * sizeof(int) bytes stored on the heap

    std::cout << *b << std::endl; // 20

    // Initializing the c array:
    for(int i = 0; i < 10; i++)
    {
        c[i] = i;
        // This is the same as:
        // *(c + i) = i;
    }

    delete b;             // Heap memory needs to be manually cleaned up.
    delete[] c;           // When memory is allocated with new[] then delete[] is used.

    // No need to deallocate a - it is automatically deallocated at the end of the scope.
}
```

Допълнение: Какво бяха pointer arithmetics?

## Запознаване с функции от по - висок ред.
Функция от по - висок ред е функция, която приема една или повече функции като аргумент, и/или връща функция като резултат. 

Нека разгледаме следния пример:
* Работим върху проект, в който често ни се налага да търсим дали някакъв елемент в масив отговаря на някакво свойство.
* Масивите са само от числа, но свойствата са различни - налага ни се да си задаваме въпроси от сорта на:
    * В масива има ли число по - голямо от 0?
    * В масива има ли четно число?
    * В масива има ли число, което се дели на 18?

Разбира се, тези въпроси можем лесно да си отговорим като просто използваме един for цикъл. Този метод си има предимства и се използва. 

Недостатъка, който ще се опитаме да избегнем в случая, е повторението на код. Общата част в кода на всички тези въпроси е следната:
```cpp
for(int i = 0; i < size; i++)
{
    if(something_is_true(arr[i]))
    {
        return true;
    }
}
return false;
```

Нещото, което се променя в случая е предикатът `something_is_true`. Можем да отделим общата част на кода в отделна функция и да подаваме предиката като аргумент на тази функция. Неформално функцията ще изглежда така: `bool any_of(const int* arr, unsigned size, Predicate p)`.

Функцията връща истина ако в масива съществува поне един елемент, за който `p` връща истина и лъжа в противен случай. 

Но какво е `Predicate` - функция. По - конкретно функция, която приема число и връща `bool`. 
В С++ подаването на функция като аргумент на функция се случва чрез **указатели към функции.**

Как изглежда това синтактично:
```cpp
T (*name)(Args...);
```

Тук:
* T е типа на връщане
* name е името на указателя към функцията
* Args... са 0 или повече аргументи.

Функцията `any_of` ще изглежда по следния начин:
```cpp
bool any_of(const int* arr, unsigned size, bool (*predicate)(int))
{
    for(int i = 0; i < size; i++)
    {
        if(predicate(arr[i]))
        {
            return true;
        }
    }
    return false;
}
```

Можем да я използваме по следния начин:
```cpp
bool is_even(int x)
{
    return (x % 2 == 0);
}

int main()
{
    int arr[] = {1, 2, 3, 4, 5};
    bool has_even_number = any_of(arr, 5, is_even);
}
```

## Структури
В уводния курс по програмиране бяха разгледани примитивни типове. Такива типове бяха int, char и тн. Езикът С++ ни дава възможността да дефинираме и свои типове от данни.

Структурите в C++ са съставен тип данни. Използват се за групиране на елементи. Елементите могат да бъдат от различен тип и с различна дължина. Последното е точно това, което различава структурите от масивите. В масивите съхраняваме данни от еднакъв тип.

```cpp
struct Point {
    double x;
    double y;
};

struct Person {
    char firstName[16];
    char lastName[16];
    unsigned short age;
};
```

## Работа със структури
Вече видяхме как можем да създадем структура. Също така видяхме, че нищо не ни пречи в структурата да имаме масив. Нищо не ни пречи и в структурата да имаме друга структура, но това малко по-късно. 

```cpp
int main() {
    Point start;    // Създаваме инстанция на Point
    start.x = 0.1;  // Променливите в start могат да бъдат достъпвани/променяни спокойно.
    start.y = 0.2;
}
```

Така създадена паметта за структурата Point се съдържа в системния стек. Нищо не ни пречи да съхраняваме структурите си в heap паметта:

```cpp
#include<iostream>
#include<cstring>

int main() {
    Person* p = new Person;

    strcpy(p->firstName, "Yavor");
    strcpy(p->lastName, "Aleksandrov");
    p->age = 12;

    std::cout << p->firstName << " " << p->lastName;

    delete p;
}
```

Също така нищо не ни пречи да подаваме структури като аргументи на функции:

```cpp
// Ако няма да променяме инстанцията я подаваме като котстантна референция.
void printPerson(const Person& p) {
    std::cout << p.firstName << " " << p.lastName << " " << p.age << std::endl;
}
```

Можем да променяме структурата:
```cpp
// Функция която променя полето age на инстанцияна на newAge.
void setAge(Person& p, unsigned short newAge) {
    p.age = newAge;
}
```

Можем и да я подаваме по копие:
```cpp
void doSomething(Person p) {
    // Работим с копие на подадената инстанция.
    p.age = 10;
}

int main() {
    Person p;
    p.age = 12;
    doSomething(p);
    std::cout << p.age << std::endl; // какво ще изведе този код?
}
```

```
Важно: Уверете се, че разбирате какво означава да подаваме променлива по копие или по референция.
```

Можем да връщаме примитивни типове от функция - защо да не можем да връщаме и съставни:

```cpp
#include<cstring>

Person createPerson(const char fName[16], const char lName[16], unsigned short age) {
    Person toReturn;

    strcpy(toReturn.firstName, fName);
    strcpy(toReturn.lastName, lName);

    toReturn.age = age;

    return toReturn;
}

int main() {
    Person p1 = createPerson("Nikola", "Svetoslavov", 22);
}
```
Можем да правим и масиви от структури:
```cpp
int main() {
    Point arr[32];

    for(int i = 0; i < 32; i++) {
        arr[i].x = rand();
        arr[i].y = rand();
    }

    Point* dynamicArr = new Point[2];
    dynamicArr[0].x = dynamicArr[0].y = 0;

    dynamicArr[1].x = dynamicArr[1].y = 1;

    delete[] dynamicArr;
}
```

## Enum
Структурите, в някакъв смисъл, ни помагат да създаваме наши типове данни. Доста често практиката изисква нашите типове данни да се класифицират по някакъв начин. Неформално казано, ако създаваме тип, който описва студент, можем да се интересуваме от това в кой курс е. Или ако създаваме тип, който описва лаптоп, може да се интересуваме какъв модел е. Общото между тези два примера е, че имаме краен брой характеристики, които описват нашия тип. 

```cpp
struct Student {
    char name[16];
    unsigned age;
    unsigned course; // Values of 1, 2, 3, 4
};
```

Това би бил наивния начин да пазим информацията в кой курс е студента. Този начин работи, но не е особено удобен. Гледайки само типа `unsigned` не можем да разберем какви биха били стойностите които може да приема. 
Езикът С++ ни дава начин да създадем собствен тип, който има за цел да служи като описаната класификация.

```cpp
enum class Course {
    First,
    Second, 
    Third,
    Fourth
};
```

Пренаписвайки структурата би изглеждала така
```cpp
struct Student {
    char name[16];
    unsigned age;
    Course course;
};
```

Първо, какво е `Course`??? Той е тип, който има краен брой стойности, описани от нас. Можем да го подаваме като част от структурата (както подаваме примитивните типове). Как да му дадем стойност?

```cpp
int main()
{
    Student myStudent;
    myStudent.course = Course::Second;
}
```
Трябва да запомните, че стойностите на enum class се достъпват през `EnumClassName::Value`. Това е за добро - така кодът става в пъти по-четим и ясен.

След като веднъж сме дали стойност можем да използваме условни конструкции за да вземаме решения базирани на стойността:
```cpp
int main()
{
    Student myStudent;
    myStudent.course = Course::Second;

    if(myStudent.course == Course::First)
    {
        std::cout << ":(";
    }

    // We can switch too!
    switch (myStudent.course)
    {
    case Course::First:

        break;
    case Course::Second:

        break;
    case Course::Third:

        break;
    case Course::Fourth:

        break;
    default:
        break;
    }
}
```

enum по подразбиране е реализиран чрез типа int. Можем да променим това използвайки следния синтаксис
```cpp
enum class MyEnum : char
{
    ValueOne,
    ValueTwo
};
```
Сега размерът на променлива от тип `MyEnum` ще бъде 1 байт а не 4, както е по подразбиране.

## Задача първа
Да се реализира функция, за превръщане на низ в число. Функцията може да допусне грешки и трябва да предоставя начин, по който можем да разберем какво точно се е объркало. (Дали всичко е ок, дали има overflow, дали низът е невалиден, дали е подаден nullptr).